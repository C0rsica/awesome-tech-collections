# 缓存



如缓存五分钟法则所讲：如果一个数据频繁被访问，那么就应该放内存中。这里的缓存就是一种读写效率都非常高的存储方案，能够应对高并发的访问请求，通常情况下也不需要持久化的保证。但相对其他存储来说，缓存一般是基于内存的，成本比较昂贵，因此不能滥用。



缓存可以分为：本地缓存和分布式缓存。

* 本地缓存：主要指的是内存中的缓存机制。在Java中，Google Guava中就提供了本地缓存的实现机制。当然使用java的ConncurrentHashMap你也可以实现自己的本地缓存方案。
* 分布式缓存：指的单独的缓存服务。几年前比较流行的是memcached，但其只是一个KV的存储，支持的数据结构太少。现在最为流行的就是Redis，能够支持丰富的数据结构，基于事件驱动的单线程非阻塞IO也能够应对高并发的场景。集群方案除了官方的redis cluster, 目前比较流行的还有豌豆荚的[codis](https://github.com/wandoulabs/codis)、twitter的[twemproxy](https://github.com/twitter/twemproxy)。

对于缓存的使用，需要注意以下几点：

* 缓存的失效机制：当给某一个key设置了有效期，那么缓存何时对此key进行删除呢？一般来说会有以下几种方式：
  * 守护进程定时去扫描key，找到已经失效的key，然后删除
  * 读取key的时候先去判断key是否失效，如果失效则删除并返回空。

* 缓存的淘汰机制：是当缓存内存达到上限时如何删除缓存中的key。Redis提供了以下数据淘汰策略：
  * volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
  * volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
  * volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
  * allkeys-lru：从数据集中挑选最近最少使用的数据淘汰
  * allkeys-random：从数据集中任意选择数据淘汰
  * no-enviction（驱逐）：禁止驱逐数据

  对于其具体的实现机制，可以参考[《Redis设计与实现》](http://redisbook.com/)一书

* 缓存的更新机制: 通常来说有四种方式：Cache aside, Read through, Write through, Write behind caching，具体的可见陈皓大神的这篇总结：[缓存更新的套路](http://coolshell.cn/articles/17416.html)。
* 缓存的服务过载保护：缓存的服务过载指的是由于缓存失效，而引起后端服务的压力骤增，进一步产生雪崩效应。这个现象和缓存更新是相关的，采取何种策略在缓存失效的时候去更新缓存直接决定了服务过载的保护机制。通常的分为客户端和服务端的应对方案。前者的方案有：基于超时的简单模式、基于超时的常规模式、基于刷新的简单模式、基于刷新的常规模式、基于刷新的续费模式。后者的方案则是很常见的流量控制和服务降级。具体的可以看美团技术团队总结的这篇文章：[Cache应用中的服务过载案例研究](http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651745239&idx=1&sn=60490558770ade79fd9f1e88f9c7c0ac&scene=1&srcid=0617o5PapWXlKUP4OxSzA7KE#rd)。

