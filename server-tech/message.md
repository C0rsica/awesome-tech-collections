# 消息中间件

软件的组织结构，从开始的面向组件到SOA、SAAS是一个逐渐演变的过程。到了今天SOA以及微服务盛行的时代，你都不好意思说自己的系统只是单一的一个系统而没有解耦成一个个service。当然，小的系统的确没有去做SOA的必要性，但一个复杂的系统拆成微服务架构确实是不得不做的事情。

先抛开协议不谈，service之间的调用方式可以分为同步调用以及异步调用。同步调用的方式无需多说，那么异步调用是怎么进行的呢？一种很常见的方式就是使用消息队列，调用方把请求放到队列中即可返回，然后等待服务提供方去队列中去获取请求进行处理，然后把结果返回给调用方即可（通过回调）。

异步调用就是消息中间件一个非常常见的应用场景。此外，消息队列的应用场景还有以下：

* 解耦: 一个事务，只关心核心的流程，需要依赖其他系统但不那么重要的事情，有通知即可，无须等待结果。
* 最终一致性: 指的是两个系统的状态保持一致，要么都成功，要么都失败，可以有一定的延迟，只要最终达到一致性即可。
* 广播: 这是消息队列最基本的功能。生产者只需要发布消息，无须关心有哪些订阅者来消费消息。
* 错峰与流控: 当上下游系统处理能力不同的时候就需要类似消息队列的方式做为缓冲区来隔开两个系统。

其实，这里消息队列的概念和操作系统中进程间通信方式的消息队列本质是相同的。消息队列有生产者和消费者两种角色。故名思议，前者生产消息，后者消费消息。这里对于生产者生产消息、消费者消费消息，有两种消息模型：队列和发布订阅。在队列模型中，一个由消费者组成的池从服务器读取消息，每一个消息都可以达到其中的某一个消费者；在发布-订阅模型中，消息被广播到所有消费者中，所有订阅了此消息的消费者都能够拿到消息。

目前主流的消息中间件，有以下几种：

* ActiveMQ
* RabbitMQ
* Kafka
* ZeroMQ

## ActiveMQ

对于ActiveMQ，需要先引入JMS这个规范。

JMS\(Java Message Service\)是一个简单的消息中间件规范，专用于JavaEE。它主要做了接口上的规范，消息传输模型和消息类型的规范，并没有给予实现。同样，它也完全没有给出服务器端的架构，你甚至可以不使用服务器直接在客户端之间传输消息，虽然可能最终结果只是一个玩具。JMS 也没有规定消息的顺序，安全，重发等特性。

ActiveMQ是对JMS的一个实现。对于此消息中间件，由于过于简单，并不推荐使用。

## RabbitMQ

AMQP\(The Advanced Message Queuing Protocol\)协议是一个比较复杂的消息中间件协议。 它是和语言无关的，在金融行业使用的新兴消息中间件，是一个异步消息传递所使用的应用层协议规范。，目标是为通用消息队列架构提供通用构建工具。

RabbitMQ即时实现了AMQP的消息队列。其关注的主要特性包括消息的顺序性、安全、事务等。其主要架构如下图所示：

![](/assets/rabbitmq.png)

其消费获取消息的方式是push，即队列里有消息就会推送给消费者。

RabbitMQ是用erlang语言编写的，而erlang是一种为并发编程而生的语言，其actor模型对于并发程序的编写做了非常好的支持。

使用RabbitMQ关键是在于其集群的搭建。一般有以下几种方式：



除此之外，阿里开源的notify也是一个侧重于事务的消息中间件。

## Kafka

Kafka是为日志而生的一个消息中间件，因此是允许消息丢失的，对事务的支持也不好，也并不能保证消息的顺序性。但是，其基于文件append、和顺序读写的方式来写入读取日志，性能是非常高的。目前，kafka多用于大数据日志的场景下面。此外，还有一个不同于RabbitMQ的地方在于kafka中消费者是通过pull的方式去获取消息的，因此在实时性上是不如RabbitMQ的，但是其使用zero-copy的技术，保证了pull的性能也是非常高的。

由于kafka是使用scala编写的，因此国内的阿里基于其原理使用Java语言实现了MetaQ并开源，当然现在MetaQ已经变成了\[RocketMQ\]\(https:\/\/github.com\/alibaba\/RocketMQ\)。不过，有一点需要注意的是它们是基于Kafka早起版本的思路实现的，后来慢慢和kafka有了很大不同。

## ZeroMQ

相比起前面描述的消息队列来说，ZeroMQ只是一个网络编程的Pattern库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之socket之上、MQ之下。对于MQ来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker服务发现和查找、事务、消费模式（ack、重投等）、集群服务等。

